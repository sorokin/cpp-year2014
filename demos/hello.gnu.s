# Пример программы Hello, world

# GNU Assembler поддерживает два вида способа записи комманд:
# Intel:
#      mov rax, 1
# AT&T:
#      movq $1, %rax
#      Суффикс "q" означает, что аргументы 64-bit, префикс "$"
#      означает константу, прификс "%" -- регист.
#
# По умолчанию используется AT&T. Директива .intel_syntax указывает,
# что необходимо использовать интеловский синтаксис, аргумент noprefix
# -- что не требуется писать "%".
        .intel_syntax   noprefix

# Директива .section начинает новую секцию
# Её синтаксис:
# .section name [, "flags"[, @type[,flag_specific_arguments]]]
#      .text -- это имя секции, так обычно называют секцию куда попадает
#               исполняемый код
#      "ax" --  это флаги флаг "a" означает что эта секция должна
#               подгружаться в память при запуске программы, этот флаг
#               включен для секций кода и данныи и выключен для метаданных,
#               "x" означает, что секция содержить исполняемый код
#      @progbits -- содержимое секции сохраняется в файле и при запуске 
#                   читается из него, противоположность этому @nobits --
#                   секция в файле не сохраняется, но при запуске она
#                   размещается в файле и заполняется нулями
        .section        .text, "ax", @progbits

# Директива .globl делает символ _start видимым для линковщика
# Линковщик настраивает точку входа в программу так, чтобы она указывала на
# _start
        .globl          _start

_start:
# Команда syscall используется для передачи управления ядру операционной системы
#      номер системного вызова передается в регистре rax
#      аргументы передаются в регистрах rdi, rsi, edx, ecx, r8, r9
#      результат системного вызова возвращается в rax
#      инструкция syscall может испортить значение регустров rcx и r11

# 1 -- это номер системого вызова sys_write, его сигнатура:
# ssize_t sys_write(unsigned int fd, const char * buf, size_t count);
        mov             rax, 1
# Первый аргумент -- это номер файлового дескриптора, куда необходимо вывести данные
# обычно чтобы получить файловый дескриптор нужно вызвать функцию open(). Но
# существует три заранее открытых файловых дескриптора:
#      0 -- stdin
#      1 -- stdout
#      2 -- stderr
        mov             rdi, 1
        mov             rsi, offset flat:msg
        mov             rdx, offset flat:msg_size
        syscall

# 60 -- это номер системного вызова sys_exit, его сигнатура:
# int sys_exit(int status);
        mov             rax, 60
        xor             rdi, rdi
        syscall

# .rodata -- так обычно называют секцию, содержащую данные доступные только для
# чтения
        .section        .rodata, "a", @progbits
msg:
# Директива .ascii выписывает в файл строчку
        .ascii          "Hello, world!\n"
# Директива .set устанавливает значение символа. Всякий раз, когда ассемблер встречает
# символ он заменяет на соотвествующее значение.
# Синтаксис:
#      .set symbol, value
# "." -- это адрес текущей комманды
        .set            msg_size, .-msg
